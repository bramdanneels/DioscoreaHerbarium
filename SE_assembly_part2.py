#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@author: Bram Danneels (bram.danneels@ugent.be)

Script for performing assembly of selected reads selected based on GC-content and coverage

usage: python reads.fastq contigs.fasta IDfile.txt kraken_db nr_cores

required software:
    R (https://www.r-project.org/)
    SMALT (https://www.sanger.ac.uk/tool/smalt-0/)
    SAMtools (https://github.com/samtools/)
    SPAdes (https://cab.spbu.ru/software/spades/)
    Kraken (https://ccb.jhu.edu/software/kraken/)
    Quast (http://bioinf.spbau.ru/quast)
    
input:
    reads.fastq: reads used for performing SE_assembly.py (metagenomic assembly)
    contigs.fasta: metagenomic contigs generated by the metagenomic assembly
    IDfile: "hull_IDs.txt" file generated by running the jupyter notebook "binning.ipynb" (*)
    kraken_db: location of kraken database for classifying contigs
output:
    folder Filtered_assembly containing the filtered reads, and the associated assembly, and summary statistics
    

(*) The notebook requires the file "contig_statistics.txt" generated by SE_assembly.py to be put in the same folder.
The notebook will plot the coverage vs. GC-content plot and will prompt the user to select the part of the graph it wishes to filter out by manually placing 6 dots on the plot
When the last dot is placed, the notbook will create the fil "hull_IDs.txt" in the same folder.
"""

from Bio import SeqIO
import sys
import subprocess as sp

script, reads, contigs, IDfile, kraken_db, cores = sys.argv

print('Extracting Contigs from IDs...\n')
#Extract contigs
assembly = SeqIO.parse(open(contigs, 'rU'), 'fasta')
IDs = []
for line in open(IDfile, 'rU'):
    ID = line.strip()
    IDs.append(ID)

FinalContigs = []
for contig in assembly:
    if contig.id in IDs:
        FinalContigs.append(contig)
print('Nr. of extracted contigs: {}'.format(len(FinalContigs)))

sp.call('mkdir Filtered_assembly', shell=True)        
SeqIO.write(FinalContigs, open('Filtered_assembly/FilteredContigs.fasta', 'w'), 'fasta')

print('Mapping reads onto contigs...\n')
#Map reads onto contigs
sp.call('smalt index -k 13 -s 1 Filtered_assembly/temp_index Filtered_assembly/FilteredContigs.fasta', shell=True)
sp.call('smalt map -n {} -f sam -o Filtered_assembly/mapping.sam Filtered_assembly/temp_index {}'.format(cores, reads), shell=True)
sp.call('rm Filtered_assembly/temp_index*', shell=True)

print('Extracting mapped reads...\n')
#Extract reads from mapping
sp.call('samtools faidx Filtered_assembly/FilteredContigs.fasta', shell=True)
sp.call('samtools view -bt Filtered_assembly/FilteredContigs.fasta.fai -F 4 Filtered_assembly/mapping.sam > Filtered_assembly/temp.bam', shell=True)
sp.call('samtools fastq Filtered_assembly/temp.bam > Filtered_assembly/MappedReads.fastq', shell=True)
sp.call('rm Filtered_assembly/temp* Filtered_assembly/FilteredContigs.fasta* Filtered_assembly/mapping*', shell=True)

print('Performing filtered assembly...\n')
#Final Assembly
sp.call('spades.py -s Filtered_assembly/MappedReads.fastq -k 21,27,33,41 --careful -t {} -o Filtered_assembly_spades'.format(cores), shell=True)
sp.call('mv Filtered_assembly_spades/contigs.fasta Filtered_assembly/contigs.fasta', shell=True)
sp.call('rm -r Filtered_assembly_spades', shell=True)

contigs = 'Filtered_assembly/contigs.fasta'
outputdir = 'Filtered_assembly'
#running quast
print("Running assembly QC with Quast\n")
sp.call('quast {} -o {}/Pre_filtered_quast'.format(contigs, outputdir), shell=True)
print('Assembly QC done\n')

#post assembly and mapping
print('Running post-assembly filtering\n')
#Map with smalt
print('Mapping reads...\n')
sp.call('smalt index -k 13 -s 4 {}/smalt_index {}'.format(outputdir, contigs), shell=True)
sp.call('smalt map -n {} -f sam -o {}/smalt_mapping.sam {}/smalt_index {}'.format(cores, outputdir, outputdir, reads), shell=True)
sp.call('rm Filtered_assembly/smalt_index*', shell=True)
#sort mapping file
sp.call('samtools sort {}/smalt_mapping.sam -O sam -T {}/temp -o {}/mapping.sorted.sam'.format(outputdir, outputdir, outputdir), shell=True)
sp.call('rm Filtered_assembly/smalt_mapping.sam Filtered_assembly/temp*', shell=True)
#extract coverage info
sp.call('samtools depth -a {}/mapping.sorted.sam > {}/samtools_depth.txt'.format(outputdir, outputdir), shell=True)
sp.call('rm Filtered_assembly/mapping.sorted.sam', shell=True)
#analyze coverage data in R
print('Making mapping summary...\n')
sp.call('Rscript ~/scripts/assembly/mapping_stats_pipe.R {} {}/samtools_depth.txt'.format(outputdir, outputdir), shell=True)
sp.call('rm Filtered_assembly/samtools_depth.txt', shell=True)
coverage = '{}/contig_statistics.txt'.format(outputdir)

print('Filtering contigs...\n')
genome = SeqIO.parse(open(contigs, 'r'), 'fasta')
goodcontigs = []
suspicious = []
all_contigs = []
lengths = []
avg_covs = []

for line in open(coverage, 'r'):
    if line.startswith('NODE'):
        triple = line.rstrip().split('\t')
        all_contigs.append(triple)
        lengths.append(int(triple[1]))
        avg_covs.append(float(triple[1])*float(triple[2]))

overall_cov = float(sum(avg_covs))/sum(lengths)
min_cov = overall_cov/3
threshold = overall_cov*10

print("Discarding contigs with length < 500bp")
print("Calculated average coverage = %d"%overall_cov)
print("Discarding contigs with average coverage below %dx"%min_cov)

for contig in all_contigs:  
    if (float(contig[2]) > min_cov):     
        if float(contig[1]) > 500:
            if float(contig[2]) < threshold:
                goodcontigs.append(contig[0])
            else:
                suspicious.append(contig[0])  

print("Found %d suspicious contigs with coverage above %dx"%(len(suspicious), threshold))

GoodContigSeq = []
suspiciousSeq = []

for contig in genome:
    if contig.id in goodcontigs:
        GoodContigSeq.append(contig)
    elif contig.id in suspicious:
        suspiciousSeq.append(contig)

OUTG = open("{}/GoodContigs.fasta".format(outputdir),"w")
OUTS = open("{}/SuspiciousContigs.fasta".format(outputdir),"w")
SeqIO.write(GoodContigSeq,OUTG,"fasta")
SeqIO.write(suspiciousSeq,OUTS,"fasta")
OUTG.close()
OUTS.close()
sp.call('cat Filtered_assembly/GoodContigs.fasta Filtered_assembly/SuspiciousContigs.fasta > Filtered_assembly/Filtered_contigs.fasta', shell=True)
contigs = 'Filtered_assembly/Filtered_contigs.fasta'

print("Running kraken on filtered contigs\n")
sp.call('kraken --preload --threads {} --db {} {} > Filtered_assembly/filCon_kraken_out'.format(cores, kraken_db, contigs), shell=True)
sp.call('kraken-translate --db {} Filtered_assembly/filCon_kraken_out > Filtered_assembly/filCon_kraken_lab'.format(kraken_db), shell=True)
sp.call('rm Filtered_assembly/filCon_kraken_out', shell=True)
print("Filtering Eukaryotic contigs\n")
filtered_IDs = []
for line in open('Filtered_assembly/filCon_kraken_lab'):
    if 'Eukaryota' in line:
        ID = line.rstrip().split('\t')[0]
        filtered_IDs.append(ID)
contigs = SeqIO.parse(open('Filtered_assembly/Filtered_contigs.fasta'), 'fasta')
OUT = open('Filtered_assembly/temp.fasta', 'w')
i, j = 0, 0
for contig in contigs:
    i += 1
    if contig.id not in filtered_IDs:
        j += 1
        SeqIO.write(contig, OUT, 'fasta')
OUT.close()

print('Filtered {} contigs from fasta, {} contigs remaining'.format(str(len(filtered_IDs)), str(j)))
sp.call('mv Filtered_assembly/temp.fasta Filtered_assembly/Filtered_contigs.fasta', shell=True)
print("Running final assembly QC\n")
sp.call('quast Filtered_assembly/Filtered_contigs.fasta -o Filtered_assembly/final_quast', shell=True)
        

