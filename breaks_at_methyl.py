#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@author: Bram Danneels (bram.danneels@ugent.be)

Script to calculate the occurence of mapped read starts in the vicinity of m4C methylated cytosine residues

input:
    mapping_file: list of mapped 5' read ends per position in the genome. Created by mapping the reads to the genome (creating input.bam), and running "bedtools genomecov -d -5 -ibam input.bam -g genome.fa > mapping_file"
    methyl_file: .gff file with methylation status, generated by RS_Modification_and_Motif_Analysis protocol from the SMRT Analysis software suit for analysing PacBio sequencing data.
    ref_genome: reference genome (in fasta format) on which the reads are mapped
output:
    Overview of average number of mapped 5' read ends in the neighbourhood of 1 to 10 bases from methylated sites, both including and exlcuding positions where no 5p reads are mapped
    
    
"""

from Bio import SeqIO
import numpy as np
from sys import argv

script, mapping_file, methyl_file, ref_genome = argv

for seq in SeqIO.parse(open(ref_genome), 'fasta'):
    genome = seq.seq
beforegenome = genome[-1]+genome[:-1]
temp = genome.complement()
compgenome = temp[1:]+temp[0]

print('Genome = {}'.format(genome))
print()
for ignore_zero in [True, False]:
    print('Ignoring positions with zero mapping') if ignore_zero else print('\nIncluding positions with zero mapping')
    print()
    baselinedict = {}    
    ReadStartDict = {}
    for line, base in zip(open(mapping_file), beforegenome):
        chrom, pos, cov = line.strip().split()
        if ignore_zero and int(cov) > 0:
            ReadStartDict[int(pos)] = (base, int(cov))
            baselinedict[base] = baselinedict.get(base, [])
            baselinedict[base].append(int(cov))
        elif not ignore_zero and int(cov) >= 0:
            ReadStartDict[int(pos)] = (base, int(cov))
            baselinedict[base] = baselinedict.get(base, [])
            baselinedict[base].append(int(cov))
    print('Baseline:')
    for base in baselinedict.keys():
        print('Base = {}\tMean = {}\tMedian = {}\tNr of bases: {}'.format(base, np.mean(baselinedict[base]), np.median(baselinedict[base]), len(baselinedict[base])))
    for N in range(11):
        print('In a neighbourhood of {} bases from methylated sites'.format(str(N)))
        methylLocFW = set()
        methylLocRV = set() 
        for line in open(methyl_file):
            if not line.startswith('#'):
                chrom, call, methyltype, pos, end, X, strand, *rest = line.strip().split()
                if methyltype == 'm4C':
                    if strand == '+':
                        for i in range(-N, N+1):
                            methylLocFW.add(int(pos)+i+1)
                    else:
                        for i in range(-N, N+1):
                            methylLocRV.add(int(pos)+i-1)
        methylDict = {}
        for line, base in zip(open(infile), beforegenome):
            chrom, pos, cov = line.strip().split()
            if ignore_zero and int(cov) > 0 and int(pos) in methylLocFW:
                methylDict[base] = methylDict.get(base, [])
                methylDict[base].append(int(cov))
            elif not ignore_zero and int(cov) >= 0 and int(pos) in methylLocFW:
                methylDict[base] = methylDict.get(base, [])
                methylDict[base].append(int(cov))
        for line, base in zip(open(infile), compgenome):
            chrom, pos, cov = line.strip().split()
            if ignore_zero and int(cov) > 0 and int(pos) in methylLocRV:
                methylDict[base] = methylDict.get(base, [])
                methylDict[base].append(int(cov))
            elif not ignore_zero and int(cov) >= 0 and int(pos) in methylLocRV:
                methylDict[base] = methylDict.get(base, [])
                methylDict[base].append(int(cov)) 
        for base in methylDict.keys():
            print('Base = {}\tMean = {}\tMedian = {}\tNr of bases: {}'.format(base, np.mean(methylDict[base]), np.median(methylDict[base]), len(methylDict[base])))
print()
